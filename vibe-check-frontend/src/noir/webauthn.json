{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":6812472007203808200,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":56},"visibility":"public"},{"name":"tx_hash_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"tx_hash","type":{"kind":"array","length":43,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"payload_hash","type":{"kind":"field"},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"program_outputs","type":{"kind":"struct","path":"ProgramOutputs","fields":[{"name":"authenticator_data","type":{"kind":"array","length":37,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"client_data_json_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"client_data_json","type":{"kind":"array","length":255,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"public"}],"param_witnesses":{"identity":[{"start":12,"end":68}],"identity_len":[{"start":11,"end":12}],"initial_state":[{"start":2,"end":6}],"initial_state_len":[{"start":1,"end":2}],"next_state":[{"start":7,"end":11}],"next_state_len":[{"start":6,"end":7}],"payload_hash":[{"start":112,"end":113}],"program_outputs":[{"start":114,"end":535}],"success":[{"start":113,"end":114}],"tx_hash":[{"start":69,"end":112}],"tx_hash_len":[{"start":68,"end":69}],"version":[{"start":0,"end":1}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"1":{"source":"use crate::cmp::Ord;\n\n// TODO: Once we fully move to the new SSA pass this module can be removed and replaced\n// by the methods in the `slice` module\nimpl<T, N> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = self.get_sorting_index(ordering);\n        let mut result = self;\n        // Ensure the indexes are correct\n        for i in 0..N {\n            let pos = find_index(sorted_index, i);\n            assert(sorted_index[pos] == i);\n        }\n        // Sort the array using the indexes\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u64; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<N>(a: [u64; N], find: u64) -> u64 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n","path":"std/array.nr"},"46":{"source":"use dep::std;\n\npub fn prefix_sha256_hash<N>(prefix_length: u8, input: [u8; N]) -> [u8; 32] {\n    let mut result = [0; 32];\n    assert(\n        [1, 2, 3, 113, 114, 133, 134, 156, 242, 243].any(|x| x == prefix_length), \"Length is not supported\"\n    );\n    if prefix_length == 1 {\n        result = std::hash::sha256(prefix(input, [0; 1]));\n    }\n    if prefix_length == 2 {\n        result = std::hash::sha256(prefix(input, [0; 2]));\n    }\n    if prefix_length == 3 {\n        result = std::hash::sha256(prefix(input, [0; 3]));\n    }\n    if prefix_length == 113 {\n        result = std::hash::sha256(prefix(input, [0; 113]));\n    }\n    if prefix_length == 114 {\n        result = std::hash::sha256(prefix(input, [0; 114]));\n    }\n    if prefix_length == 133 {\n        result = std::hash::sha256(prefix(input, [0; 133]));\n    }\n    if prefix_length == 134 {\n        result = std::hash::sha256(prefix(input, [0; 134]));\n    }\n    if prefix_length == 156 {\n        result = std::hash::sha256(prefix(input, [0; 156]));\n    }\n    if prefix_length == 242 {\n        result = std::hash::sha256(prefix(input, [0; 242]));\n    }\n    if prefix_length == 243 {\n        result = std::hash::sha256(prefix(input, [0; 243]));\n    }\n    result\n}\n\npub fn concatenate_arrays(a: [u8; 37], b: [u8; 32]) -> [u8; 69] {\n    let mut result = [0; 69];\n    for i in 0..37 {\n        result[i] = a[i];\n    }\n    for i in 0..32 {\n        result[i+37] = b[i];\n    }\n    result\n}\n\npub fn check_pubkey_matches_identity(pub_key_x: [u8; 32], pub_key_y: [u8; 32], identity: str<56>) {\n    // Compute the publickey as concatenation of pub_key_x and pub_key_y\n    let mut pub_key = [0; 64];\n    for i in 0..32 {\n        pub_key[i] = pub_key_x[i];\n    }\n    for j in 0..32 {\n        pub_key[j+32] = pub_key_y[j];\n    }\n    // Compute the address as the hash of the publickey\n    let address: [u8; 32] = std::hash::sha256(pub_key);\n\n    // identity is the last 20bytes of the address.\n    // Assert that there is a match between identity provided and identity computed from pubkeys\n    for k in 0..20 {\n        assert(address[12 + k] == identity.from_hex_to_uint_slice(2 * k, 2 * k + 2) as u8);\n    }\n}\n\nfn prefix<N, M>(input: [u8; N], mut result: [u8; M]) -> [u8; M] {\n    for i in 0..M {\n        result[i] = input[i];\n    }\n    result\n}\n","path":"/home/maximilien/vibe-check/noir-webauthn/src/utils.nr"},"47":{"source":"mod utils;\n\nuse dep::std;\nuse dep::std::println;\nuse crate::utils::{prefix_sha256_hash, concatenate_arrays, check_pubkey_matches_identity};\n\nglobal CLIENT_DATA_JSON_LEN = 255;\n\nstruct ProgramOutputs {\n    authenticator_data: [u8; 37],\n    client_data_json_len: u8,\n    client_data_json: [u8; CLIENT_DATA_JSON_LEN],\n    signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n}\n\n\nfn main(\n    version: pub u32,\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    identity_len: pub u8,\n    identity: pub str<56>,\n    tx_hash_len: pub u32,\n    tx_hash: pub [u8; 43],\n    payload_hash: pub Field,\n    success: pub bool,\n    program_outputs: pub ProgramOutputs\n) {\n    let client_data_json_hash = prefix_sha256_hash(\n        program_outputs.client_data_json_len,\n        program_outputs.client_data_json\n    );\n    let concat = concatenate_arrays(program_outputs.authenticator_data, client_data_json_hash);\n    let hashed_data = std::hash::sha256(concat);\n\n    // Verifying pub_key matches the identity\n    check_pubkey_matches_identity(program_outputs.pub_key_x, program_outputs.pub_key_y, identity);\n\n    // The txhash IS the challenge\n    for i in 0..(tx_hash.len()) {\n        assert(tx_hash[i] == program_outputs.client_data_json[36 + i]);\n    }\n\n    let valid_signature = std::ecdsa_secp256r1::verify_signature(\n        program_outputs.pub_key_x,\n        program_outputs.pub_key_y,\n        program_outputs.signature,\n        hashed_data\n    );\n\n    assert(valid_signature);\n    assert(version == 1);\n    assert(tx_hash_len == 43);\n    assert(identity_len == 56);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(payload_hash == payload_hash);\n\n    let mut signature = [0 as Field; 64];\n    for i in 0..program_outputs.signature.len() {\n        signature[i] = program_outputs.signature[i] as Field;\n    }\n    assert(success == true);\n}\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_134() {\n    let authenticator_data = [\n        73, 150, 13, 229, 136, 14, 140, 104, 116, 52, 23, 15, 100, 118, 96, 91, 143, 228, 174, 185, 162, 134, 50, 199, 153, 92, 243, 186, 131, 29, 151, 99, 1, 0, 0, 0, 2\n    ];\n    let client_data_json = [\n        123, 34, 116, 121, 112, 101, 34, 58, 34, 119, 101, 98, 97, 117, 116, 104, 110, 46, 103, 101, 116, 34, 44, 34, 99, 104, 97, 108, 108, 101, 110, 103, 101, 34, 58, 34, 77, 68, 69, 121, 77, 122, 81, 49, 78, 106, 99, 52, 79, 87, 70, 105, 89, 50, 82, 108, 90, 106, 65, 120, 77, 106, 77, 48, 78, 84, 89, 51, 79, 68, 108, 104, 89, 109, 78, 107, 90, 87, 89, 34, 44, 34, 111, 114, 105, 103, 105, 110, 34, 58, 34, 104, 116, 116, 112, 58, 47, 47, 108, 111, 99, 97, 108, 104, 111, 115, 116, 58, 53, 49, 55, 51, 34, 44, 34, 99, 114, 111, 115, 115, 79, 114, 105, 103, 105, 110, 34, 58, 102, 97, 108, 115, 101, 125,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// Padding with 121 zeros (134+121 = 255) \n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0\n    ];\n    let signature = [\n        80, 114, 197, 245, 128, 150, 206, 160, 135, 105, 51, 205, 42, 143, 25, 53, 119, 97, 166, 196, 95, 98, 53, 63, 168, 171, 63, 85, 41, 42, 196, 134, 26, 198, 126, 179, 109, 99, 41, 92, 86, 45, 240, 238, 196, 106, 77, 219, 146, 196, 183, 80, 225, 170, 66, 218, 169, 244, 230, 252, 61, 213, 29, 201\n    ];\n    let challenge = [\n        77, 68, 69, 121, 77, 122, 81, 49, 78, 106, 99, 52, 79, 87, 70, 105, 89, 50, 82, 108, 90, 106, 65, 120, 77, 106, 77, 48, 78, 84, 89, 51, 79, 68, 108, 104, 89, 109, 78, 107, 90, 87, 89\n    ];\n    let pub_key_x = [\n        201, 91, 99, 172, 65, 154, 80, 154, 189, 195, 194, 210, 62, 219, 224, 36, 43, 134, 143, 236, 137, 178, 121, 35, 112, 146, 103, 238, 37, 100, 145, 26\n    ];\n    let pub_key_y = [\n        169, 8, 63, 83, 58, 93, 192, 39, 114, 115, 138, 176, 56, 254, 162, 127, 93, 19, 156, 93, 51, 9, 194, 161, 253, 10, 203, 128, 171, 254, 255, 83\n    ];\n\n    let program_outputs = ProgramOutputs { authenticator_data, client_data_json_len: 134, client_data_json, signature, pub_key_x, pub_key_y };\n\n    let version = 1;\n    let initial_state_len = 4;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 4;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"c59b18d3bdaccb4d689048559a9bb6e8265293bf.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n    let payload_hash = 0x0d05cdc496bde53c7f93a50ef18b8ff2084c18c65bb2b9cbac7c3b814befa0a3 as Field;\n    let success = true;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        payload_hash,\n        success,\n        program_outputs\n    );\n}\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [35,9,110,138,212,71,172,124,13,7,194,158,153,63,87,67,67,25,22,122,101,253,159,175,106,50,52,157,164,70,148,46,126,152,146,190,137,37,199,95,249,115,198,94,237,198,18,23,200,185,52,157,189,205,144,63,212,29,177,20,24,255,160,127];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [15,206,241,12,21,160,54,11,79,72,44,109,43,45,101,54,210,243,13,236,51,33,47,66,187,38,60,249,64,70,37,252];\n    let pub_key_y = [43,221,114,86,240,184,224,51,237,41,173,85,147,130,225,150,159,150,44,23,57,92,82,37,27,40,69,123,252,224,3,197];\n\n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 4;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 4;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"3f368bf90c71946fc7b0cde9161ace42985d235f.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n    let payload_hash = 0x2cd4a07375bb18c67225f96dc94a459803676221c55d76cfbb28238e5279c86d as Field;\n    let success = true;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        payload_hash,\n        success,\n        program_outputs,\n    );\n}\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243_bis() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [216,184,64,61,79,81,150,39,72,191,167,234,52,253,225,66,52,192,76,159,65,164,134,34,212,255,104,99,14,53,71,115,0,190,96,135,49,186,213,189,93,36,212,143,36,92,27,42,44,103,95,153,46,59,158,22,223,196,84,102,51,209,135,233];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [35,250,194,235,47,86,159,70,36,137,145,195,83,245,203,137,12,28,43,171,167,226,44,90,199,107,235,0,229,229,133,67];\n    let pub_key_y = [84,107,152,100,72,140,98,57,186,30,76,187,129,194,209,158,96,37,254,211,60,198,27,227,167,247,204,51,145,53,120,95];\n\n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 4;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 4;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"ae0e5100ea7d28905ce690194c0717cd93756a20.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n    let payload_hash = 0x25c2c8e15ffcf1cfb9193d9663186fe76764564274a65d719b087d972b45fd11 as Field;\n    let success = true;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        payload_hash,\n        success,\n        program_outputs,\n    );\n}\n","path":"/home/maximilien/vibe-check/noir-webauthn/src/main.nr"},"48":{"source":"use dep::std::println;\n\nglobal UPPERCASE_A_INDEX: u8 = 65;\nglobal UPPERCASE_Z_INDEX: u8 = 90;\nglobal LOWERCASE_A_INDEX: u8 = 97;\nglobal LOWERCASE_Z_INDEX: u8 = 122;\nglobal ZERO_INDEX: u8 = 48;\nglobal NINE_INDEX: u8 = 57;\nglobal ASCII_TABLE_START_INDEX: u8 = 0;\nglobal SORTED_ASCII_TABLE: [str<1>; 127] = [    \n    \"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\t\",\"\\n\",\"\\0\",\"\\0\",\"\\r\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\n    \" \",\"!\",\"\\\"\",\"#\",\"$\",\"%\",\"&\",\"'\",\"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",\n    \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\n    \":\",\";\",\"<\",\"=\",\">\",\"?\",\"@\",\n    \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\n    \"[\",\"\\\\\",\"]\",\"^\",\"_\",\"`\",\n    \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\n    \"{\",\"|\",\"}\",\"~\"\n];\n\n// Functions \nfn code_at<N>(s: str<N>, index: u64) -> u8 {\n    assert(index < N);\n    s.as_bytes()[index]\n}\n\nfn char_at<N>(s: str<N>, index: u64) -> str<1> {\n    let byte = code_at(s, index);\n    let ascii_index = byte - ASCII_TABLE_START_INDEX;\n    SORTED_ASCII_TABLE[ascii_index]\n}\n\nfn index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            index = i as i64;\n            match_count += 1;\n        } else if (index != -1) & (i - index < M) {\n            if (str_bytes[i] != substr_bytes[i - index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    // If the match count is not equal to the length of the substring,\n    // then the substring is not in the string\n    // Can happen when looking at a substring that is at the end of the string\n    // but the match is only partial\n    if match_count != M {\n        index = -1;\n    }\n\n    index\n}\n\nfn last_index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    let mut final_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            final_index = temp_index;\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        final_index = temp_index;\n    }\n\n    final_index\n}\n\n// We use Field instead of integers for the Vector here as integers \n// don't seem to work well with Vectors at the moment\nfn indexes_of<N, M>(s: str<N>, substr: str<M>) -> Vec<Field> {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut indexes: Vec<Field> = Vec::new();\n    for i in 0..N {\n        if (match_count == M) {\n            indexes.push(temp_index as Field);\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        indexes.push(temp_index as Field);\n    }\n\n    indexes\n}\n\nfn contains<N, M>(s: str<N>, substr: str<M>) -> bool {\n    index_of(s, substr) != -1\n}\n\nfn occurrences_of<N, M>(s: str<N>, substr: str<M>) -> u64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut occurrences = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            temp_index = -1;\n            match_count = 0;\n            occurrences += 1;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        occurrences += 1;\n    }\n\n    occurrences\n}\n\nfn digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    assert((byte >= ZERO_INDEX) & (byte <= NINE_INDEX), \"Character is not a digit\");\n    byte - ZERO_INDEX\n}\n\nfn hex_digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    if (byte >= ZERO_INDEX) & (byte <= NINE_INDEX) {\n        byte - ZERO_INDEX\n    } else if (byte >= UPPERCASE_A_INDEX) & (byte <= UPPERCASE_Z_INDEX) {\n        byte - UPPERCASE_A_INDEX + 10\n    } else if (byte >= LOWERCASE_A_INDEX) & (byte <= LOWERCASE_Z_INDEX) {\n        byte - LOWERCASE_A_INDEX + 10\n    } else {\n        assert(false, \"Character is not a hex digit\");\n        0\n    }\n}\n\nfn to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = digit_at(s, i);\n        result = result * 10 + digit as u64;\n    }\n    result\n}\n\nfn to_uint<N>(s: str<N>) -> u64 {\n    to_uint_slice(s, 0, N)\n}\n\nfn to_int<N>(s: str<N>) -> i64 {\n    if char_at(s, 0) == \"-\" {\n        -1 * to_uint_slice(s, 1, N) as i64\n    } else {\n        to_uint_slice(s, 0, N) as i64\n    }\n}\n\nfn from_hex_to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = hex_digit_at(s, i);\n        result = result * 16 + digit as u64;\n    }\n    result\n}\n\nfn from_hex_to_uint<N>(s: str<N>, with_prefix: bool) -> u64 {\n    if with_prefix {\n        from_hex_to_uint_slice(s, 2, N)\n    } else {\n        from_hex_to_uint_slice(s, 0, N)\n    }\n}\n\nfn to_array_of_chars<N>(s: str<N>) -> [str<1>; N] {\n    let mut result: [str<1>; N] = [\" \"; N];\n    for i in 0..N {\n        result[i] = char_at(s, i);\n    }\n    result\n}\n\n// Struct\n\nstruct String<N> {\n    value: str<N>,\n    len: u64,\n}\n\n// Implementation over String struct\n\nimpl<N> String<N> {\n    fn new(value: str<N>) -> Self {\n        Self { value, len: N }\n    }\n\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self.value, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self.value, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self.value, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self.value, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self.value, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self.value, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self.value, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self.value, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self.value, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self.value, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self.value, 0, self.len)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self.value)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self.value, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self.value, with_prefix)\n    }\n\n    fn to_array_of_chars(self: Self) -> [str<1>; N] {\n        to_array_of_chars(self.value)\n    }\n}\n\n// Trait\ntrait StringTrait {\n    fn code_at(self, index: u64) -> u8;\n    fn char_at(self, index: u64) -> str<1>;\n    fn index_of<M>(self, substr: str<M>) -> i64;\n    fn last_index_of<M>(self, c: str<M>) -> i64;\n    fn indexes_of<M>(self, c: str<M>) -> Vec<Field>;\n    fn contains<M>(self, substr: str<M>) -> bool;\n    fn occurrences_of<M>(self, c: str<M>) -> u64;\n    fn digit_at(self, index: u64) -> u8;\n    fn hex_digit_at(self, index: u64) -> u8;\n    fn to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn to_uint(self) -> u64;\n    fn to_int(self) -> i64;\n    fn from_hex_to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn from_hex_to_uint(self, with_prefix: bool) -> u64;\n}\n\n// Implementation for str type\nimpl<N> StringTrait for str<N> {\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self, 0, N)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self, with_prefix)\n    }\n}\n\n// Tests for String struct\n#[test]\nfn test_init() {\n    let s = String::new(\"hello\");\n    assert(s.len == 5);\n    assert(s.value == \"hello\");\n}\n\n#[test]\nfn test_char_at() {\n    let s = String::new(\"hello\");\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_code_at() {\n    let s = String::new(\"hello\");\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_index_of() {\n    let s = String::new(\"hello\");\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_last_index_of() {\n    let s = String::new(\"hello\");\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_indexes_of() {\n    let s = String::new(\"hello\");\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_contains() {\n    let s = String::new(\"hello\");\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_occurrences_of() {\n    let s = String::new(\"hello\");\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_digit_at() {\n    let s = String::new(\"20231219\");\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_hex_digit_at() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_to_uint() {\n    let s = String::new(\"20231219\");\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_to_int() {\n    let s = String::new(\"-25\");\n    assert(s.to_int() == -25);\n\n    let s = String::new(\"25\");\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_to_uint_slice() {\n    let s = String::new(\"2023/12/19\");\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_from_hex_to_uint_slice() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_from_hex_to_uint() {\n    let uppercase_hex = String::new(\"0x1324ABCDEF\");\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = String::new(\"0x1234abcdef\");\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = String::new(\"1234abcdef\");\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = String::new(\"0x000001\");\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n\n#[test]\nfn test_to_array_of_chars() {\n    let s = String::new(\"hello\");\n    let arr = s.to_array_of_chars();\n    assert(arr[0] == \"h\");\n    assert(arr[1] == \"e\");\n    assert(arr[2] == \"l\");\n    assert(arr[3] == \"l\");\n    assert(arr[4] == \"o\");\n}\n\n// Tests for String trait\n#[test]\nfn test_trait_char_at() {\n    let s = \"hello\";\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_trait_code_at() {\n    let s = \"hello\";\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_trait_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_trait_last_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_trait_indexes_of() {\n    let s = \"hello\";\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_trait_contains() {\n    let s = \"hello\";\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_trait_occurrences_of() {\n    let s = \"hello\";\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_trait_digit_at() {\n    let s = \"20231219\";\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_trait_hex_digit_at() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_trait_to_uint() {\n    let s = \"20231219\";\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_trait_to_int() {\n    let s = \"-25\";\n    assert(s.to_int() == -25);\n\n    let s = \"25\";\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_trait_to_uint_slice() {\n    let s = \"2023/12/19\";\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint_slice() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint() {\n    let uppercase_hex = \"0x1324ABCDEF\";\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = \"0x1234abcdef\";\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = \"1234abcdef\";\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = \"0x000001\";\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n","path":"/home/maximilien/nargo/github.com/madztheo/noir-string-utils.gitmain/src/lib.nr"}},"names":["main"]}