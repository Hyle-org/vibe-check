{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":4461950063200147690,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":56},"visibility":"public"},{"name":"tx_hash_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"tx_hash","type":{"kind":"array","length":43,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"payload_hash","type":{"kind":"field"},"visibility":"public"},{"name":"program_outputs","type":{"kind":"struct","path":"ProgramOutputs","fields":[{"name":"authenticator_data","type":{"kind":"array","length":37,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"client_data_json_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"client_data_json","type":{"kind":"array","length":255,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"public"}],"param_witnesses":{"identity":[{"start":12,"end":68}],"identity_len":[{"start":11,"end":12}],"initial_state":[{"start":2,"end":6}],"initial_state_len":[{"start":1,"end":2}],"next_state":[{"start":7,"end":11}],"next_state_len":[{"start":6,"end":7}],"payload_hash":[{"start":112,"end":113}],"program_outputs":[{"start":113,"end":534}],"tx_hash":[{"start":69,"end":112}],"tx_hash_len":[{"start":68,"end":69}],"version":[{"start":0,"end":1}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"5Z3bjuzIYWX/pZ/1kCTjRv3KYDCQbXkgwGgZljzAQPC/T+hyqltdVGxMnaSRudabWl3JqHXIPhHMiL32n374l9/+03/+7//1ux//9fd/+OHX/+NPP/zb7//5N3/83e9/nP/0px/q/vjL//mHf//Nj3/+5z/88Tf/8ccfft3r+NUPv/3xX3749eiP//rVD//6u3/77Q+/Lv2/fvXpR7dy/O1H963+9KPt4keP8mh/+9mj7NvHD29Xlz3bx2XLzy/7P381f+ntHX/p/R1/6eMdf+nyjr90fcdfur3jL93f8Zce7/hLn2/4Sx/vOCMe7zgjHv+dM+Jxnte/9F9+k3ec5o53nOaOd5zmjnec5o7+Mv91vePcdbzj3FXece4q7zh3lZeZu8o7zl3lHeeu8o5zV3nHuau8zNxV3nHuKu84d9V3nLvqO85d9WXmrvqOc1d9x7mrvuPcVd9x7qovM3fVd5y76jvOXe0d5672jnNXe5m5q73j3NXece5q7zh3tXecu9rLzF3ttrnrL1f/3klmr/3b1funq/fHrVffbr36fuvVv/fvzP2s356Z45dXb9/9PfNRH9+u3sanq593Xv27v7ldX3279erf+8wc49uPlv2XVx/fvflSPv4mKG37dPV+69XHrVc/77z6dz+RZWx/+9G6//Lq2+O7dy/nrty3y9f2+fL13su3ey/f77389z6WtX+7fNt++R/stn/3vn47vj2XrR6fL3/ce/ly7+XrvZf/3gez9W+X75/WTXNN9b1/KfTj20TS6+Pz5bd7L7/fe/nj3st/74PZ+7fLj23/5eXbd58wG/u3ld/487//5eXPWy//3Q9muPx27+W/98Ec7dvlz8f5y8uP7z6mee7l2+VL+Xz5fu/lx72XP2+9/Hc/mGf7dvnt8fjlXL4/vv+w82PfPgYo2+cB6t0DtLsH6HcP8N1fVjzaxwBzefbLAfbvzw5s2/gY4BifBzjuHqDcPUC9e4Dvfky3j5/d9scv5/e9XEdxzvPx8ej9fEHW//ahy4lpPk8/sfz81e7y9xr122p+G2P//Hvt3z3E/hjnx7dxf/9ne/XN3Va+fcsz//f4GfS4/G/nsZ8//Q3589n16sfPRzs+psqx/fyH/0p7qGiLiraqaBuLdnz7W+qck/Bn2q6iHSra00R7/cbwtrTzt/2gPY7PtJuKlrWWSrSstVSiLSzacn7Q9ou/pVhrqUTLWkslWtZaKtGy1lJb/6Ddr1YXrLVUoC2wtVSgha2lAi1rvt1/Wl3s5fGZljXfJlrWfJtoWfNtomXNt39HWz/TsubbQFtZ822iZb3N7x+bkOc+2mda1tt8oi0qWtjqItDCVhfnB+2xXdDCVheBFra6CLSw1cWatrHm22MfH7R1/0zLmm8TLWu+TbSs+TbRsubbv6Ptn2lZ822iZc23gbaz3m+Pn04iHOfnE0Sd9X1yurfg1cUFLXh1cUFbTN9LdfBewQUteK/ggha8V3BBq9or6Kq9gqHaKxistVSihe2MBFrVOcdRVLSwc46BFnbOMdDCzjkGWtg5x0ALy4yss14nay2VaFlrqUSryt+esPztOut1FhUtLH8baFX521O1ljpVa6kTlhlZ0taHKX9bH7DMyDLrVR+w/G2ghX0vFWiLihb2vdQy61UfsO+lAi1sLRVoTfnbuoH3gR6facH7QBe0sIRMoGXNt4nWdKambqYzNXUznampG+yUyTLrVXfYKZNAC1tdBFpT/rbCzKTrrFeFmUkTLWx1EWhN+dsKs1eus14VZq9MtOCEzAWtKX9bYfbKdUKmwuyViRacv72ghSVSl6nFCvM5pnsLXl18poX5HBOtKTNSiykzUgt4r+CCtqhoVXsFZFfnBa1qr0Dl6qwqV2eFuTrDOcdq6hmpMDNpojXlbyvMTJpoTfnb+vpm0tZ+oj0/f2n6+rLRBPDkFc+nSuA5xHn7EO1x/xDb/UM8Yxb7KD2/HsJU91lhks1Ea6r7rDDJZqI11X1WmGQz0ZrqPitMKZpoVa/hMKVoolW9hsOUoonWVPdZYUrRRGuq+6wwpWiiNdV9VphSNNGa6j4rTCmaaE11nxWmnUy0prrPCtNOJlrVEQKYdjLRqo5jwkSMIVwJEzEmWlPdZ4WJGBOtqe6zwkSMidZU99lgIsZEa6r7bA/WfJtoTXWfDSbrS7Smus8Gk/UlWlO4ssHUhOuYcIOpCdO9NckMGkxNmGhNccOmUhM2lZqwbaa4YaOJGNe0NBFjoDXtFTSaiDHQmtQNDSZiXJ9zbDARY6I11X223VRR1XZTRVWDSTYDLUyyuc56NZhkM9Ga6j4bTLKZaIso69Vgks1Ea6r7bDClaKJVraVgStFAC1OKJlpT/rbBlKLrrFeDKUUTbVHRmvK3DaYUXWe9GkwpmmhNdZ8NphQNtDDt5Drr1WDayUTLmm8TrSl/215fO/nMHc3Xd1Q+lVZ1pqaZ6j5bM9V9tmaq+2wwM2miLaasF8xMmmhNdZ8NZiYNtDB7Zch6weyVidZU99lg9spEy5pvQ0IGZq9MtOD87QUtLJG6Ti3CfI7h3sJ8jokWvLq4oFVlRoYqMzKKilaVvyW7Oi9oVXsFZFfnBa0qf6tydTaYqzOcczxNPSMNZiZNtEVFq8rfwsykifbNu0Hb68tGE8DtzaP98bh/iO3+Ifb7h3jGLLYsN+0P1tSxDld2mGQz0ZrqPjtMsploTXWfHSbZDLSbqe6zw5Siidb0Gt5hStFEW1S0ptfwDlOKrsOVHaYUTbSmus8OU4oGWphSdB2u7DClaKI11X12mFI00ZrqPjtMO5loTXWfHaadDLQw7eT6CEGHaScTrek4ZoeJGNfhyg4TMSZaU91nh4kYE62p7rPDRIyBFiZiTLSw1UWgZc2363Blh8n6Eq2p7rPDZH2J1lT32WGyvkBbTeHKDlMTrmPCHaYmTPe2qGhNMoOuUhN2lZqwq9SEvZrihp0mYgy0qr0Cmogx0JrUDZ0mYgy0qnOOMBFjojXVffZmqqjqzVRR1WGSzURrqvvsMMlmojXVfXaYZDPRmuo+O0yymWhNdZ8dphRNtKq1FEwpmmhNGqwOU4omWlPdZ4cpRROtqe6zw5SiidZU99lhStFEa6r77DClaKI11X12mHYy0ZrqPjtMO5loVWdqXt9R+VRa05ma8TDVfY6Hqe5zPEx1n+NRVLSmus8BM5MmWlPd54CZSQMtzF65znoNmL0y0ZrqPgfMXploTQmZAbNXJlpw/vaCFpZIXaYWB8znGO4tzOeYaMGriwtaU2Zk7EVFa6r7HGRX5wWtaa9gkF2dF7SqvQKVq3OoXJ0D5upcn3Mch6lnZMDMpInWlL8dMDNpojXlb8frm0nX3aDj9WWjAaDc3jw6ynb/EPv9Qxz3D/GMWWxZbjpgks11uHLAJJuJ1lT3OWCSzURrqvscMMlmojXVfQ6YUjTRql7DYUrRRKt6DYcpRROtqe5zwJSiidZU9zlgStFEa6r7HDClaKI11X0OmFI00ZrqPgdMO5loTXWfA6adTLSqIwQw7WSiVR3HhIkYQ7gSJmJMtKa6zwETMSZaU93ngIkYE62p7nPARIyJ1lT3OWCyvkRrqvscMFlfojXVfQ6YrC/RqsKVMDVhiAnD1ITp3qpkBjA1YaJVxQ1VasKhUhOeD1Pc8KSJGAOtaa/gpIkYA21R0ZrUDSdMxLg+53jCRIyJ1lT3eT5MFVXnZqqoOmGSzURrqvs8YZLNRFtUtKb87QmTbK6zXidMsploTXWfJ0wpGmhhStGwuoApRROtSYN1wpSiibaIsl4nTCmaaE11nydMKZpoTXWfJ0wpGmhhStFEa8rfnjDt5DrrdcK0k4nWVPd5wrSTidZ0puZ8fUflM2mL6kxNMdV9nsVU93k+RQf6PrSm/O0JM5Ous14nzEyaaE11nyfMTBpoYfbKddbrhNkrEy1rvk20pvztCbNXrhMyJ8xemWjB+dvPtDCf4zq1eMJ8junemuo+T5jPMdEW0/dSTZUZaaa6z5Ps6rygVe0VkF2dn2nJrs4LWlX+VuXqPGGuznDOsRcVraln5ISZSROtKn8LM5Mm2jfvBj1fXzaaAG5vHj3Hfv8Qx/1DlPuHeMYstiw3PWGSzRCuhEk2E62p7vOESTYDLUyyGcKVMMlmojXVfZ4wpWiiLablPEwpmmhVr+EwpWiiNdV9njCl6JL2eMCUookWFjcMtKK6z0krqvuctEVFC1tLBVpR3eekFdV9Hg+YdjLRgo8QXNCKjhBMWpHCe9Ky5ttEK6r7nLSius9JK6r7nLSw1cWaFiZiXIYrJ62o7nPSiuo+Jy1sdRFoRXWfk1ZU9zlpRXWfkxZc9/mZFibrW0bSJq0oXDlpReHKSVs8MeFJK6r7nLQimcGkFckMJq0objhpRXHD42FSE05aUdxw0qr2CmgixkBbVLQidcOkFakbJq3onOOkFcUNJ62o7vN4VFFF1aQVVVRNWlFF1aQV1X1O2qKiFdV9TlpR/nbSiuo+J62o7nPSiuo+jwdMKZpoVWspmFI00Yo0WJO2qGhFdZ+TVlT3OWlFdZ+TVpS/nbSius/jAVOKJlpR3eekVeVvYdrJkPWCaScTrajuc9Kq8revr5185o7m6zsqn0qrOlMzRHWfk7aoaEV1n5NWlb+FmUlD1gtmJk20orrP4wEzkyZaUd3npGXNt4lWVPc5aVX5W5i9MiRkYPbKRAvO336i3WA+x3VqcYP5HNO9FdV9TtqiojVlRiaWilZU9zlpTfnbjezq/ExLdnVe0Jr2CjaVq3NTuTo3mKtzfc5x20Q9I5NW1DMyaU352w1mJk20pvzt9vpm0mU36AR4+eVRAri7eXQOcdw/RLl/iHr/EM+YxVblpnMIUd3npBXVfU5aUd3nscEkm4lWVPc5aUV1n5NWVPc5aYuKVvUaDlOKJlrVazhMKZpoTXWfG0wpmmhNdZ8bTCmaaE11nxtMKZpoTXWfG0wpmmhNdZ8bTDuZaE11nxtMO5loVUcIYNrJRKs6jgkTMa7DlRtMxJhoTXWfG0zEmGhNdZ8bTMSYaE11nxtMxJhoTXWfG0zWl2hNdZ8bTNaXaE11nxtM1pdoVeFKmJowxIRhasJ0b00ygw2mJky0qrihSk24qdSE21DFDWkixkBbVLSqvQKaiDHQqtQNMBFjOOcIEzEGWpiIMdGaKqq201RRtcEkm4m2mLJeMMlmojXVfW4wyWaiNdV9bjDJ5pp2f5jqPneYUjTRmtZSO0wpmmiLitaUv91hStF11muHKUUTranuc4cpRQMtTCm6znrtMKVoojXVfe4wpWiiNdV97jDtZKI11X3uMO1koH197eQTdzT313dUPpXWdKZmf7b48qWzXvtuqvvcd1Pd5w4zkyZaU93nDjOTBlqYmTTRmvK3O8xeuc567TB7ZaI11X3uMHtlojUlZHaYvTLQwuyViRaWSF2mFneYzzHd26KiBa8uLmhNmZG9mDIjezHVfe5kV+dnWrKr84JWtVdAdnVe0Jryt7vK1bnDXJ3hnGM19YzsMDNpojXlb3eYmTTQwsykifbNu0H315eNJoDbm0f3Z0s7r4ao9w/R7h/iGbPYstx0h0k21+HKHSbZDLQwyWaihcUNA62p7nOHSTYTbVHRwtQNgVb1Gg5TiiZa1Ws4TCkaaGFK0RCuhClFE62p7nOHKUUTbTGFK2FK0URrqvvcYUrRQAvTToZwJUw7mWhNdZ87TDuZaFnzbThCANNOJlrVcUyYiDGEK2EixjXtARMxJlrY6iLQmuo+D5iIMdEWFS1sdRFoTXWfB0zWF2hhsr5EC677vKA11X0eMFlfomXNt4kWJjNYxoQPmJow3VuTzOCAqQkDrUpNeKjUhIdKTXjsprjhQRMxBlrTXsFBEzEGWpO64aCJGAOt6ZzjARMxJlpT3ed8lFW0poqqAybZTLSmus8DJtlMtKa6zwMm2Uy0prrPAybZTLSmus8DphRNtKq1FEwpmmhNGqwDphRNtKa6zwOmFE20prrPA6YUTbSmus8DphRNtKa6zwOmFE20prrPA6adTLSmus8Dpp1MtKozNa/vqHwqrepMTTPVfR7NVPd5NFPd5wEzkyZaU93nATOTJlpT3ecBM5MmWlPd5wGzVyZaU93nAbNXJlpVQgZmr0y04PztBS0skbpOLcJ8junemuo+D5jPMdGqMiNDlRkZprrPg+zqvKBV7RWQXZ0XtKq9ApWr81C5Og+YqzOcczxNPSMHzEyaaE352wIzkyZaU/62vL6ZdN0NWl5fNpoAynMBPhdqlke9f4h2/xD9/iGeMYsty00LTLK5DlcWmGQz0ZrqPgtMsploTXWfBSbZTLSmus8CU4omWtNreIEpRROt6jUcphRNtKa6zwJTiiZaU91ngSlFE62p7rPAlKKJ1lT3WWBK0UAL006uw5UFpp1MtKa6zwLTTiZa0xGCAtNOJlrTccwCEzGuw5UFJmJMtKa6zwITMSZaU91ngYkYE62p7rPARIyJ1lT3WWCyvkRrqvssMFlfojXVfRaYrC/RmsKVBaYmXMeEC0xNmO6tSWZQYGrCRGuKGxaVmrCo1ISlFRWtaq+AJmIMtKq9ApqIMdCa1A0FJmIM5xxhIsZEa6r7LN1UUVV6UdGaKqoKTLIZsl4wyWaiNdV9FphkM9DCJJsh6wWTbCZaU91ngSlFE20xrS5gStFEa9JgFZhSNNGa6j4LTCkaaGFK0USryt/ClKIh6wVTiibaoqJV5W9h2smQ9YJpJ9e0FaadTLSm/G19fe3kE3c06+s7Kp9Ky5pvE62p7rM+THWf9WGq+6wwM2mghZlJ11mvCjOTJlpT3WeFmUkTranus8LslYnWVPdZYfbKQAuzV64TMhVmr0y04PztBW0RpRYrzOeY7q2p7rPCfI6J1pQZqbspM1IPU91nJbs6L2hVewVkV+cFbVHRmvK3VeXqrDBX5/qcYz1MPSMVZiYNtDAzaaI15W8rzEyaaN+8G7S+vmw0AdzePFpLu3+Ifv8Q4/4hnjGLLctNK0yyuQ5XVphkM9Ga6j4rTLKZaF9+nnliuLLCJJuJ1lT3WWFK0USreg2HKUUDLUwpmmhVr+Ewpeg6XFlhStFEW1S0sLhhoDXVfVaYUjTRmuo+K0wpGmhh2skQroRpJxMta75NtOAjBBe0qiMEMO1kolUdx4SJGEO4EiZiTLSmus8KEzEm2mIKV8JEjInWVPdZYSLGQAuT9YVwJUzWl2hNdZ8VJutLtKz5NkTSYLK+RKsKV8LUhCEmDFMTru9tg6kJE61JZtBUasKmUhO2R1HRmuKGjSZiDLSmvYJGEzEGWpO6odFEjIHWdM6xwUSMidZU99m2oqI1VVQ1mGQz0ZrqPhtMsploTXWfDSbZTLSmus8Gk2wmWlPdZ4MpRROtai0FU4omWpMGq8GUoonWVPfZYErRRGuq+2wwpWiiNdV9NphSNNGa6j4bTCmaaE11nw2mnUy0prrPBtNOJlrVmZrXd1Q+lVZ1pqaY6j5bMdV9tmKq+2wwM2miNdV9NpiZNNGa6j4bzEyaaE11nw1mr0y0prrPBrNXJlpVQgZmr0y04PztBS0skbpMLTaYzzHdW1PdZ4P5HBOtKjPSVZmRbqr7bGRX5wWtaq+A7Oq8oFXtFahcnU3l6mwwV2c459hNPSMNZiZNtKr8LcxMmmhV+dvXN5Ouu0Hb68tGE8DtzaNt9PuHGPcPcd4+xFN8n8ty0waTbIZwJUyymWhNdZ8NJtlMtKa6zwaTbCZaU91ngylFE63pNbzDlKKJ1vQa3mFK0URrqvvsj6KiNdV9dphSNNGa6j47TCmaaE11nx2mFE20prrPDtNOJlpT3WeHaScTrekIQYdpJxOt6Thmh4kY1+HKDhMxJlpT3WeHiRgTranus8NEjInWVPfZYSLGQAuT9a3DlR0m60u0prrPDpP1JVpT3WeHyfoSrSlc2WFqwnVMuMPUhOHewtSEidYkM+gqNWFXqQm7Sk3Yiylu2GkixkCr2iugiRjXtDQRY6A1qRs6TMQYzjnCRIyJtqhoTRVVvZoqqjpMsploTXWfHSbZDLQwyWaiNeVvO0yyuc56dZhkM9EWFa0pf9thStGwuoApRROtSYPVYUrRQAtTioasF0wpmmhNdZ8dphRNtMWU9YIpRROtqe6zw5SigRamnQxZL5h2MtGa6j47TDuZaFnzbdjRfH1H5VNpVWdqhqnusw9T3Wc/TXWfHWYmTbSmus8OM5Mm2qKiVeVvYfbKkPWC2SvXtANmr0y0pvztgNkr1wmZAbNXJlrWfJtoYYnUZWpxwHyO6d6a6j4HzOcYaGE+x/X3UmMzZUbGZqr7HGRX5wVtUdGa9goG2dV5QWvK3w6Vq3PAXJ3rc45jN/WMDJiZNNGa8rcDZiZNtEVF++bdoOP1ZaMJ4Pbm0bGP+4e4vXl0HI/7h3jGLLYsNx0wyeY6XDlgks1Ey5o6Ei0sbhhoTXWfAybZTLSmus8BU4oGWphSNCznYUrRRKt6DYcpRRNtEYUrB0wpmmhNdZ8DphRNtKa6zwFTigZamFI00cLWUoGWNd+uw5UDpp1MtKa6zwHTTiZa1RECmHYy0MK0k4nWVPc5YCLGRFtUtLDVRaA11X0OmIgx0ZrqPgdMxBhoYbK+EK6EyfoSLWu+TbTgus8LWlPd54DJ+hKtKlwJUxOGmDBMTZjurUpmAFMTJtpi+l5KpSYcKjXhGKq4IU3EGGhVewU0EWOgVakbaCLGQKs65wgTMSZaU93nOE0VVeM0VVQNmGQz0ZrqPk+YZDPRmuo+T5hkM9Ga6j7PR1HRmuo+T5hSNNGa1lInTCmaaE0arBOmFE20prrPE6YUTbSmus8TphRNtKa6zxOmFE20prrPE6YUDbQw7eQ663XCtJOJ1lT3ecK0k4nWdKbmfH1H5VNpTWdqzt1U93keprrP8zDVfZ4wM2miNdV9njAzaaI11X2eMDNpojXVfZ4we2WiNdV9njB7ZaI1JWROmL0y0YLztxe0sETqMrV4wnyO6d6a6j5PmM8x0ZoyI2c1ZUbOaqr7PMmuzgta1V4B2dV5QavaK1C5Ok+Vq/OEuTrDOcdm6hk5YWbSRGvK354wM2miNeVvz9c3k667Qc/Xl40mgNubR892e/Po2R/3D7HdP8QzZrFluekJk2yGcCVMsploTXWfJ0yymWhNdZ8nTLKZaE11nydMKZpoVa/hMKVoolW9hsOUoonWVPd5wpSiidZU93nClKKJ1lT3ecKUoonWVPd5wpSiidZU93nCtJOJ1lT3ecK0k4lWdISgPGDayUQrOo45aUV1n5O2qGhFdZ+TFra6CLSius9JK6r7nLSius/ygIkYE62o7nPSsubbRCuq+5y04LrPC1pR3eekFYUrJ60oXFkeMDXhMiY8aUV1n5NWJDOYtEVFK4obTlpR3HDSiuKGk1YUN5y0qr0Cmogx0Kr2CmgixkArUjdM2uI55zhpRXHDSSuq+5y0ooqqSSuqqJq0ooqq8oBJNpdZr0krqvuctKK6z0kryt9O2uLJek1aUd3npBXVfU5aUf520qrWUjClaKCFKUUTrSh/O2lFdZ+TVlT3OWmLilaUv520orrPSSuq+5y0orrPSSvK35YHTDu5zHpNWlHd56RlzbeJVpS/nbSqMzWv76h8Kq3qTE0X1X1OWlHd56QV1X1OWlX+FmYmDVkvmJk00YrqPietKn8Ls1eGrBfMXploRXWfk1aVv4XZK0NCBmavTLTg/O0FLSyRuk4twnyO4d7CfI6JFry6uKBVZUZOVWbkLCpaVf6W7Oq8oFXtFZBdnRe0pvztpnJ1bjBX5/qc4/YQ9YxMWlHPyKQtKlpT/naDmUkT7Xt3g06Al18eJYC7m0fLtj3uH2K7f4j9/iGeMYutyk3nEKypYx2u3GCSzUQrqvuctLC4YaAV1X1OWlHdZ9l2Ud3npIWpGwKt6jUcphRNtEVFq3oNhylF1+HKDaYUTbSius9JC4sbrmlhStF1uHKDKUUTrajuc9LC1lKBVlT3OWlFdZ+TVlT3OWnBRwg+08K0k+EIAUw7mWhNxzE3mIhxHa7cYCLGRGuq+9xgIsZEa6r73GAixkALEzEmWtjqItCy5tt1uHKDyfoSranuc4PJ+hKtqe5zg8n6Am0zhSs3mJpwHRPeYGrCdG+LitYkM9hUasJNpSbcVGrCranihjQRY6BV7RXQRIyB1qRu2GgixkCrOucIEzEmWlPd59ZNFVVbN1VUbTDJZqI11X1uMMlmojXVfW4wyWaiNdV9bjDJZqI11X1uMKVoolWtpWBK0USr0mDBlKKJ1lT3ucGUoonWVPe5wZSiidZU97nBlKKJ1lT3ucOUoonWVPc5/wBUtKa6zx2mnUy0pjM1++s7Kp9KazpTs2+mus99M9V97pup7nOHmUkTranuc4eZSROtqe5zh5lJAy3MXrnOeu0we2WiNdV97jB7ZaI1JWR2mL0y0YLztxe0sETqMrW4w3yO4d7CfI6JFry6uKA1ZUb2o6hoTXWfO9nVeUGr2isguzovaFV7BSpX565yde4wV+f6nONeTD0jO8xMmmhN+dsdZiZNtKb87f76ZtJ1N+j++rLRAFBvbx7d63b/EPv9Qxz3D/GMWWxZbrrDJJvrcOUOk2wmWlPd5w6TbCZaU93nDpNsJlpT3ecOU4omWtVrOEwpmmhVr+EwpWiiNdV97jClaKI11X3uMKVoojXVfe4wpWiiNdV97jClaKI11X3uMO1kojXVfe4w7WSiVR0hgGknE63qOCZMxBjClTARY6I11X3uMBFjojXVfe4wEWOiNdV97jARY6I11X3uMFlfojXVfe4wWV+iNdV9HjBZX6I1hSsPmJpwHRM+HkV1b00ygwOmJky0prjhoVITHio14bGZ4oYHTcQYaE17BQdNxBhoi4rWpG44YCLG9TnHAyZiTLSmus9jM1VUHbupouqASTYTranu84BJNhNtUdGa8rcHTLK5znodMMlmojXVfR4wpWighSlFw+oCphRNtCYN1gFTiibaIsp6HTClaKI11X0eMKVoojXVfR4wpWighSlFE60pf3vAtJPrrNcB004mWlPd5wHTTiZa1Zma13dUPpO2qs7UVFPd51FNdZ/HU3Sg70Nryt8eMDPpOut1wMykidZU93nAzKSBFmavXGe9Dpi9MtGy5ttEa8rfHjB7ZUjIwOyViRacv/1MC/M5htQizOeY7q2p7vOA+RwTbTF9L9VVmZFuqvs8yK7OC1rVXgHZ1fmZluzqvKBV5W9Vrs4D5uoM5xxHUdGaekYOmJk00arytzAzaaJ9827Q4/Vlowng9ubR49zvH+K4f4hy/xDPmMWW5aYHTLIZwpUwyWaiNdV9HjDJ5pq2wCSb63BlgUk2E62p7rPAlKKJtoiW8wWmFE20ptfwAlOKJlpT3WeBKUUDLUwpmmhhccNAa6r7LDClaKItKlrYWirQmuo+C0w7GWhh2slECz5CcEFrOkJQYNrJRMuabxOtqe6zwESMidZU91lgIsZACxMxrsOVBSZiTLSmus8CEzEmWlPdZ4HJ+hKtqe6zwGR9gRYm61tH0gpM1pdoTeHKAlMTrmPCBaYmTPfWJDMoMDVhojXFDYtKTVhUasJSTXHDQhMxBlrVXgFNxBhoTeqGQhMxBlrVOUeYiDHRmuo+SzNVVJVmqqgqMMlmojXVfRaYZDPRmuo+C0yymWhNdZ8FJtlMtKa6zwJTiiZa1VoKphRNtCYNVoEpRROtqe6zwJSiidZU91lgStFEa6r7LDClaKI11X0WmFI00ZrqPgtMO5loTXWfBaadTLSqMzWv76h8Kq3qTM1pqvssz3Zwvjitqe6zwMykidZU91lgZtJEa6r7rDAzaaI11X3WB2u+TbSmus8Ks1cmWlNCpsLslYkWnL/9TAvzOa5TixXmc0z31lT3WWE+x0RryozUzZQZqZup7rOSXZ0XtKa9gkp2dV7QmvYKqsrVWVWuzgpzda7POdbd1DNSYWbSRGvK31aYmTTRmvK39fXNpOtu0Pr6stEEcHvzaD2O+4co9w9R7x/iGbPYsty0wiSb63BlhUk2E62p7rPCJJuJ1lT3WWGSzURrqvusMKVoolW9hsOUoolW9RoOU4omWlPdZ4UpRROtqe6zwpSiidZU91lhStFEa6r7rDClaKI11X1WmHYy0ZrqPitMO5loVUcIYNrJRKs6jgkTMa7DlRUmYky0prrPChMxJlpT3WeFiRgTranus8JEjInWVPdZYbK+RGuq+6wwWV+iNdV9VpisL9GqwpUwNWGICcPUhOneqmQGMDVholXFDVVqwqpSE9ZTFTekiRgDbVHRqvYKaCLGQKtSN8BEjOGcI0zEuKZtMBFjojVVVLWHqaKqwSSbibaIsl4NJtlMtKa6zwaTbCZaU91ng0k2A+1mqvtsMKVoolWtpWBK0URbVLSm/G2DKUXXWa8GU4omWlPdZ4MpRQMtTCm6zno1mFI00ZrqPhtMKZpoTXWfDaadTLSmus8G004G2tfXTj5xR7O9vqPyqbSmMzXt2eLLl856tcNU99kOU91ng5lJE62p7rPBzKSBFmYmTbSm/G2D2SvXWa8Gs1cmWlPdZ4PZKxOtKSHTYPbKQAuzVyZaWCJ1mVpsMJ9jurdFRQteXVzQmjIjrZoyI62a6j4b2dX5mZbs6rygVe0VkF2dF7Sm/G1TuTobzNUZzjk2U89Ig5lJE60pf9tgZtJACzOTJto37wZtry8bTQC3N4+2Z0s7r4ao9w/R7h/iGbPYsty0wSSbIVwJk2wGWphkM9HC4oaB1lT32WCSzURbVLQwdUOgVb2Gw5SiiVb1Gg5TigZamFI0hCthStFEa6r7bDClaKItpnAlTCmaaE11nw2mFF3Tdph2ch2u7DDtZKI11X12mHYy0bLm2/URgg7TTiZa03HMDhMxrsOVHSZiDLQwEWOiha0uAq2p7rPDRIyJtqhoYauLQGuq++wwWV+ghcn6Ei247vOC1lT32WGyvkTLmm8TLUxmsIwJd5iaMN1bk8ygw9SEgValJuwqNWFXqQn7YYobdpqIMdCq9gpoIsZAa1I3dJqIMdCazjl2mIgx0ZrqPnsxVVT1Yqqo6jDJZqI11X12mGQz0ZrqPjtMsploTXWfHSbZTLSmus8OU4omWtVaCqYUTbQmDVaHKUUTranus8OUoonWVPfZYUrRRGuq++wwpWiiNdV9dphSNNGa6j47TDuZaE11nx2mnUy0qjM1r++ofCqt6kxNN9V99m6q++zdVPfZYWbSRGuq++wwM2miNdV9dpiZNNGa6j47zF6ZaE11nx1mr0y0qoQMzF6ZaMH52wtaWCJ1nVqE+RzTvTXVfXaYzzHRqjIjpyozcprqPgfZ1XlBa9orGGRX5wWtaa9gPIqK1pS/HTBX5/qc43iYekYGzEyaaE352wEzkyZaU/52vL6ZdN0NOl5fNpoAynMBPhdqjq3eP0S7f4h+/xDPmMWW5aYDJtlchysHTLKZaE11nwMm2Uy0prrPAZNsJlpT3eeAKUUTreo1HKYUTbSq13CYUjTRmuo+B0wpmmhNdZ8DphRNtKa6zwFTiiZaU93ngClFAy1MO7kOVw6YdjLRmuo+B0w7mWhVRwhg2slEazqOOWAixnW4csBEjInWVPc5YCLGRGuq+xwwEWOiNdV9DpiIMdGa6j4HTNaXaE11nwMm60u0prrPAZP1JVpTuHLA1ITrmPCAqQnTvTXJDAZMTZhoVXFDlZpwqNSEoxcVrWqvgCZiDLSqvQKaiDHQqtQNMBFjOOcIEzEmWlPd5ximiqoxiorWVFE1YJLNkPWCSTYTranuc8Akm4EWJtkMWS+YZDPRmuo+B0wpmmiLaXUBU4omWpUGC6YUTbSmus8BU4quaU+YUjTRmvK3J0wpus56nTClaKItKlpT/vaEaSfXWa8Tpp0MtDDtZKI15W/P19dOPnFH83x9R+VTaVnzbaI11X2em6nu89xMdZ8nzEwaaGFm0nXW64SZSROtqe7zhJlJE62p7vOE2SsTranu84TZKwMtzF65TsicMHtlogXnby9oiyi1eMJ8junemuo+T5jPMdGaMiPzv2UTbTHVfZ5kV+cFrWqvgOzqvKAtKlpT/vZUuTpPmKtzfc7xLKaekRNmJg20MDNpojXlb0+YmTTRvnk36Pn6stEEcHvz6Fnb/UP0+4cY9w/xjFlsWW56wiSb63DlCZNsJlpT3ecJk2wm2pefZ54Yrjxhks1Ea6r7PGFK0USreg2HKUUDLUwpmmhVr+EwpWgIV8KUoom2qGhhccNAa6r7PGFK0URrqvs8YUrRQAvTToZwJUw7mWhZ822iBR8huKBVHSGAaScTreo4JkzEGMKVMBFjojXVfZ4wEWOiLaZwJUzEmGhNdZ8nTMS4pK0PmKxvGa6ctKK6z0krqvuctOC6zwta1ny7jKRNWlG4ctKKwpWTFiYzWMWEJ62o7rM+YGrCRCuSGUxaUdxw0orihpO2qGhFccNJK9ormLSivYJJK9ormLQidUN90ESMgVZ0znHSiuKGk1ZU9zlpi4pWVFE1aUUVVZNWVPc5aUV1n5NWVPdZHzDJZqIV1X1OWlHd56QV1X1O2qKiVa2lYErRRCvSYE1aUf520orqPusDphRNtKK6z0kryt9OWlHd56QtKlpR3eekFeVvJ62o7rM+YNrJRCuq+5y0ovztpFWdqXl9R+VTaVVnaqqo7nPSiuo+J62o7rM+YGbSRCuq+5y0orrPSSuq+5y0RUUrqvuctKK6z0krqvusD5i9MtGqEjIwe2WiBedvL2hhidR1ahHmc0z3VlT3OWnBq4sLWlVmZKgyI0NU9zlpVflbsqvzgraoaFV7BSZX56RV5W9hrs5wznGIekbqA2YmTbSq/C3MTJpoVfnb1zeTLrtBJ8DLL48SwN3No3OIfv8Q4/4hzruH2J7i+1yVm84hRHWfk1ZU9zlpRXWfk/blp46n0orqPietqO5z0orqPictTN0QaE2v4RtMKZpoTa/hG0wpmmhFdZ+TtqhoRXWfkxYWNwy0orrPSSuq+5y0orrPusGUoolWVPc5aVnzbaIV1X1OWvARggta0xGCDaadTLSm45gbTMS4DlduMBFjohXVfU7aoqIV1X1OWlHd56Q11X1uMBFjoIXJ+tbhyg0m60u0prrPDSbrS7Smus8NJutLtKZw5QZTE65jwhtMTRjuLUxNmGhNMoNNpSbcVGrCTaUm3KopbrjRRIyBVrVXQBMxrmlpIsZAa1I3bDARYzjnCBMxJtqiojVVVG3NVFG1wSSbidZU97nBJJuBFibZTLSq/C1MshmyXjDJZqItKlpV/hamFA2rC5hSNNGaNFgbTCkaaGFK0ZD1gilFE62p7nODKUUTbTFlvWBK0URrqvvcYErRQAvTToasF0w7mWhNdZ8bTDuZaFnzbdjRfH1H5VNpVWdqTlPd53aa6j73h6nuc4eZSROtqe5zh5lJE21R0ZrytzvMXrnOeu0we2WghdkrE60pf7vD7JXrhMwOs1cmWtZ8m2hhidRlanGH+RzTvTXVfe4wn2Oghfkc199L7bspM7LvprrPnezqvKAtKlrTXsFOdnVe0Jryt7vK1bnDXJ3rc477YeoZ2WFm0kRryt/uMDNpoi0q2jfvBt1fXzaaAG5vHt2Pcf8QtzeP7uVx/xDPmMWW5ab7P5Bs7uVjiOOx/3yIv37q+NKnypc+Vb/0qfalT/UvfWp86VPnVz71D5R06VPblz71pWejfunZqF96NuqXno36pWejfunZqF96NuqXno32pWejfenZaF96NtqXno32pWejfenZaF96NtqXno32pWejfenZ6F96NvqXno3+pWejf+nZ6F96NvqXno3+pWejf+nZ6F96NvqXno3xpWdjfOnZGF96NsaXno3xpWfjH0StjuPjU/UxPn/q+tmY3zJ9fOronz91/WzUun18qh2fP3X9bNTePz51ls+fun422uODq+3t06f+QVynlcfHp9rnP8N/EHtp/ePdo53186eun43++HjB7MfFWMeXPlW+9Kn6pU9dPxu9fPxp9HbxJ9+/9KnxpU+d/7+fmv/wf37zH7/7zT/922//MD/y53/3nz/+8x9/9/sf//aPf/y///7XfzN/9v8B","file_map":{"1":{"source":"use crate::cmp::Ord;\n\n// TODO: Once we fully move to the new SSA pass this module can be removed and replaced\n// by the methods in the `slice` module\nimpl<T, N> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = self.get_sorting_index(ordering);\n        let mut result = self;\n        // Ensure the indexes are correct\n        for i in 0..N {\n            let pos = find_index(sorted_index, i);\n            assert(sorted_index[pos] == i);\n        }\n        // Sort the array using the indexes\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u64; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<N>(a: [u64; N], find: u64) -> u64 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n","path":"std/array.nr"},"46":{"source":"use dep::std;\n\npub fn prefix_sha256_hash<N>(prefix_length: u8, input: [u8; N]) -> [u8; 32] {\n    let mut result = [0; 32];\n    assert(\n        [1, 2, 3, 113, 114, 133, 134, 156, 242, 243].any(|x| x == prefix_length), \"Length is not supported\"\n    );\n    if prefix_length == 1 {\n        result = std::hash::sha256(prefix(input, [0; 1]));\n    }\n    if prefix_length == 2 {\n        result = std::hash::sha256(prefix(input, [0; 2]));\n    }\n    if prefix_length == 3 {\n        result = std::hash::sha256(prefix(input, [0; 3]));\n    }\n    if prefix_length == 113 {\n        result = std::hash::sha256(prefix(input, [0; 113]));\n    }\n    if prefix_length == 114 {\n        result = std::hash::sha256(prefix(input, [0; 114]));\n    }\n    if prefix_length == 133 {\n        result = std::hash::sha256(prefix(input, [0; 133]));\n    }\n    if prefix_length == 134 {\n        result = std::hash::sha256(prefix(input, [0; 134]));\n    }\n    if prefix_length == 156 {\n        result = std::hash::sha256(prefix(input, [0; 156]));\n    }\n    if prefix_length == 242 {\n        result = std::hash::sha256(prefix(input, [0; 242]));\n    }\n    if prefix_length == 243 {\n        result = std::hash::sha256(prefix(input, [0; 243]));\n    }\n    result\n}\n\npub fn concatenate_arrays(a: [u8; 37], b: [u8; 32]) -> [u8; 69] {\n    let mut result = [0; 69];\n    for i in 0..37 {\n        result[i] = a[i];\n    }\n    for i in 0..32 {\n        result[i+37] = b[i];\n    }\n    result\n}\n\npub fn check_pubkey_matches_identity(pub_key_x: [u8; 32], pub_key_y: [u8; 32], identity: str<56>) {\n    // Compute the publickey as concatenation of pub_key_x and pub_key_y\n    let mut pub_key = [0; 64];\n    for i in 0..32 {\n        pub_key[i] = pub_key_x[i];\n    }\n    for j in 0..32 {\n        pub_key[j+32] = pub_key_y[j];\n    }\n    // Compute the address as the hash of the publickey\n    let address: [u8; 32] = std::hash::sha256(pub_key);\n\n    // identity is the last 20bytes of the address.\n    // Assert that there is a match between identity provided and identity computed from pubkeys\n    for k in 0..20 {\n        assert(address[12 + k] == identity.from_hex_to_uint_slice(2 * k, 2 * k + 2) as u8);\n    }\n}\n\nfn prefix<N, M>(input: [u8; N], mut result: [u8; M]) -> [u8; M] {\n    for i in 0..M {\n        result[i] = input[i];\n    }\n    result\n}\n","path":"/home/maximilien/vibe-check/noir-webauthn/src/utils.nr"},"47":{"source":"mod utils;\n\nuse dep::std;\nuse dep::std::println;\nuse crate::utils::{prefix_sha256_hash, concatenate_arrays, check_pubkey_matches_identity};\n\nglobal CLIENT_DATA_JSON_LEN = 255;\n\nstruct ProgramOutputs {\n    authenticator_data: [u8; 37],\n    client_data_json_len: u8,\n    client_data_json: [u8; CLIENT_DATA_JSON_LEN],\n    signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n}\n\n\nfn main(\n    version: pub u32,\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    identity_len: pub u8,\n    identity: pub str<56>,\n    tx_hash_len: pub u32,\n    tx_hash: pub [u8; 43],\n    payload_hash: pub Field,\n    program_outputs: pub ProgramOutputs\n) {\n    let client_data_json_hash = prefix_sha256_hash(\n        program_outputs.client_data_json_len,\n        program_outputs.client_data_json\n    );\n    let concat = concatenate_arrays(program_outputs.authenticator_data, client_data_json_hash);\n    let hashed_data = std::hash::sha256(concat);\n\n    // Verifying pub_key matches the identity\n    check_pubkey_matches_identity(program_outputs.pub_key_x, program_outputs.pub_key_y, identity);\n\n    // The txhash IS the challenge\n    for i in 0..(tx_hash.len()) {\n        assert(tx_hash[i] == program_outputs.client_data_json[36 + i]);\n    }\n\n    let valid_signature = std::ecdsa_secp256r1::verify_signature(\n        program_outputs.pub_key_x,\n        program_outputs.pub_key_y,\n        program_outputs.signature,\n        hashed_data\n    );\n\n    assert(valid_signature);\n    assert(version == 1);\n    assert(tx_hash_len == 43);\n    assert(identity_len == 56);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(payload_hash == payload_hash);\n\n    let mut signature = [0 as Field; 64];\n    for i in 0..program_outputs.signature.len() {\n        signature[i] = program_outputs.signature[i] as Field;\n    }\n}\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_134() {\n    let authenticator_data = [\n        73, 150, 13, 229, 136, 14, 140, 104, 116, 52, 23, 15, 100, 118, 96, 91, 143, 228, 174, 185, 162, 134, 50, 199, 153, 92, 243, 186, 131, 29, 151, 99, 1, 0, 0, 0, 2\n    ];\n    let client_data_json = [\n        123, 34, 116, 121, 112, 101, 34, 58, 34, 119, 101, 98, 97, 117, 116, 104, 110, 46, 103, 101, 116, 34, 44, 34, 99, 104, 97, 108, 108, 101, 110, 103, 101, 34, 58, 34, 77, 68, 69, 121, 77, 122, 81, 49, 78, 106, 99, 52, 79, 87, 70, 105, 89, 50, 82, 108, 90, 106, 65, 120, 77, 106, 77, 48, 78, 84, 89, 51, 79, 68, 108, 104, 89, 109, 78, 107, 90, 87, 89, 34, 44, 34, 111, 114, 105, 103, 105, 110, 34, 58, 34, 104, 116, 116, 112, 58, 47, 47, 108, 111, 99, 97, 108, 104, 111, 115, 116, 58, 53, 49, 55, 51, 34, 44, 34, 99, 114, 111, 115, 115, 79, 114, 105, 103, 105, 110, 34, 58, 102, 97, 108, 115, 101, 125,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// Padding with 121 zeros (134+121 = 255) \n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0\n    ];\n    let signature = [\n        80, 114, 197, 245, 128, 150, 206, 160, 135, 105, 51, 205, 42, 143, 25, 53, 119, 97, 166, 196, 95, 98, 53, 63, 168, 171, 63, 85, 41, 42, 196, 134, 26, 198, 126, 179, 109, 99, 41, 92, 86, 45, 240, 238, 196, 106, 77, 219, 146, 196, 183, 80, 225, 170, 66, 218, 169, 244, 230, 252, 61, 213, 29, 201\n    ];\n    let challenge = [\n        77, 68, 69, 121, 77, 122, 81, 49, 78, 106, 99, 52, 79, 87, 70, 105, 89, 50, 82, 108, 90, 106, 65, 120, 77, 106, 77, 48, 78, 84, 89, 51, 79, 68, 108, 104, 89, 109, 78, 107, 90, 87, 89\n    ];\n    let pub_key_x = [\n        201, 91, 99, 172, 65, 154, 80, 154, 189, 195, 194, 210, 62, 219, 224, 36, 43, 134, 143, 236, 137, 178, 121, 35, 112, 146, 103, 238, 37, 100, 145, 26\n    ];\n    let pub_key_y = [\n        169, 8, 63, 83, 58, 93, 192, 39, 114, 115, 138, 176, 56, 254, 162, 127, 93, 19, 156, 93, 51, 9, 194, 161, 253, 10, 203, 128, 171, 254, 255, 83\n    ];\n\n    let program_outputs = ProgramOutputs { authenticator_data, client_data_json_len: 134, client_data_json, signature, pub_key_x, pub_key_y };\n\n    let version = 1;\n    let initial_state_len = 4;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 4;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"c59b18d3bdaccb4d689048559a9bb6e8265293bf.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n    let payload_hash = 0x0d05cdc496bde53c7f93a50ef18b8ff2084c18c65bb2b9cbac7c3b814befa0a3 as Field;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        payload_hash,\n        program_outputs\n    );\n}\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [35,9,110,138,212,71,172,124,13,7,194,158,153,63,87,67,67,25,22,122,101,253,159,175,106,50,52,157,164,70,148,46,126,152,146,190,137,37,199,95,249,115,198,94,237,198,18,23,200,185,52,157,189,205,144,63,212,29,177,20,24,255,160,127];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [15,206,241,12,21,160,54,11,79,72,44,109,43,45,101,54,210,243,13,236,51,33,47,66,187,38,60,249,64,70,37,252];\n    let pub_key_y = [43,221,114,86,240,184,224,51,237,41,173,85,147,130,225,150,159,150,44,23,57,92,82,37,27,40,69,123,252,224,3,197];\n\n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 4;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 4;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"3f368bf90c71946fc7b0cde9161ace42985d235f.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n    let payload_hash = 0x2cd4a07375bb18c67225f96dc94a459803676221c55d76cfbb28238e5279c86d as Field;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        payload_hash,\n        program_outputs,\n    );\n}\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243_bis() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [216,184,64,61,79,81,150,39,72,191,167,234,52,253,225,66,52,192,76,159,65,164,134,34,212,255,104,99,14,53,71,115,0,190,96,135,49,186,213,189,93,36,212,143,36,92,27,42,44,103,95,153,46,59,158,22,223,196,84,102,51,209,135,233];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [35,250,194,235,47,86,159,70,36,137,145,195,83,245,203,137,12,28,43,171,167,226,44,90,199,107,235,0,229,229,133,67];\n    let pub_key_y = [84,107,152,100,72,140,98,57,186,30,76,187,129,194,209,158,96,37,254,211,60,198,27,227,167,247,204,51,145,53,120,95];\n\n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 4;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 4;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"ae0e5100ea7d28905ce690194c0717cd93756a20.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n    let payload_hash = 0x25c2c8e15ffcf1cfb9193d9663186fe76764564274a65d719b087d972b45fd11 as Field;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        payload_hash,\n        program_outputs,\n    );\n}\n","path":"/home/maximilien/vibe-check/noir-webauthn/src/main.nr"},"48":{"source":"use dep::std::println;\n\nglobal UPPERCASE_A_INDEX: u8 = 65;\nglobal UPPERCASE_Z_INDEX: u8 = 90;\nglobal LOWERCASE_A_INDEX: u8 = 97;\nglobal LOWERCASE_Z_INDEX: u8 = 122;\nglobal ZERO_INDEX: u8 = 48;\nglobal NINE_INDEX: u8 = 57;\nglobal ASCII_TABLE_START_INDEX: u8 = 0;\nglobal SORTED_ASCII_TABLE: [str<1>; 127] = [    \n    \"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\t\",\"\\n\",\"\\0\",\"\\0\",\"\\r\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\n    \" \",\"!\",\"\\\"\",\"#\",\"$\",\"%\",\"&\",\"'\",\"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",\n    \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\n    \":\",\";\",\"<\",\"=\",\">\",\"?\",\"@\",\n    \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\n    \"[\",\"\\\\\",\"]\",\"^\",\"_\",\"`\",\n    \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\n    \"{\",\"|\",\"}\",\"~\"\n];\n\n// Functions \nfn code_at<N>(s: str<N>, index: u64) -> u8 {\n    assert(index < N);\n    s.as_bytes()[index]\n}\n\nfn char_at<N>(s: str<N>, index: u64) -> str<1> {\n    let byte = code_at(s, index);\n    let ascii_index = byte - ASCII_TABLE_START_INDEX;\n    SORTED_ASCII_TABLE[ascii_index]\n}\n\nfn index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            index = i as i64;\n            match_count += 1;\n        } else if (index != -1) & (i - index < M) {\n            if (str_bytes[i] != substr_bytes[i - index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    // If the match count is not equal to the length of the substring,\n    // then the substring is not in the string\n    // Can happen when looking at a substring that is at the end of the string\n    // but the match is only partial\n    if match_count != M {\n        index = -1;\n    }\n\n    index\n}\n\nfn last_index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    let mut final_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            final_index = temp_index;\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        final_index = temp_index;\n    }\n\n    final_index\n}\n\n// We use Field instead of integers for the Vector here as integers \n// don't seem to work well with Vectors at the moment\nfn indexes_of<N, M>(s: str<N>, substr: str<M>) -> Vec<Field> {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut indexes: Vec<Field> = Vec::new();\n    for i in 0..N {\n        if (match_count == M) {\n            indexes.push(temp_index as Field);\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        indexes.push(temp_index as Field);\n    }\n\n    indexes\n}\n\nfn contains<N, M>(s: str<N>, substr: str<M>) -> bool {\n    index_of(s, substr) != -1\n}\n\nfn occurrences_of<N, M>(s: str<N>, substr: str<M>) -> u64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut occurrences = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            temp_index = -1;\n            match_count = 0;\n            occurrences += 1;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        occurrences += 1;\n    }\n\n    occurrences\n}\n\nfn digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    assert((byte >= ZERO_INDEX) & (byte <= NINE_INDEX), \"Character is not a digit\");\n    byte - ZERO_INDEX\n}\n\nfn hex_digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    if (byte >= ZERO_INDEX) & (byte <= NINE_INDEX) {\n        byte - ZERO_INDEX\n    } else if (byte >= UPPERCASE_A_INDEX) & (byte <= UPPERCASE_Z_INDEX) {\n        byte - UPPERCASE_A_INDEX + 10\n    } else if (byte >= LOWERCASE_A_INDEX) & (byte <= LOWERCASE_Z_INDEX) {\n        byte - LOWERCASE_A_INDEX + 10\n    } else {\n        assert(false, \"Character is not a hex digit\");\n        0\n    }\n}\n\nfn to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = digit_at(s, i);\n        result = result * 10 + digit as u64;\n    }\n    result\n}\n\nfn to_uint<N>(s: str<N>) -> u64 {\n    to_uint_slice(s, 0, N)\n}\n\nfn to_int<N>(s: str<N>) -> i64 {\n    if char_at(s, 0) == \"-\" {\n        -1 * to_uint_slice(s, 1, N) as i64\n    } else {\n        to_uint_slice(s, 0, N) as i64\n    }\n}\n\nfn from_hex_to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = hex_digit_at(s, i);\n        result = result * 16 + digit as u64;\n    }\n    result\n}\n\nfn from_hex_to_uint<N>(s: str<N>, with_prefix: bool) -> u64 {\n    if with_prefix {\n        from_hex_to_uint_slice(s, 2, N)\n    } else {\n        from_hex_to_uint_slice(s, 0, N)\n    }\n}\n\nfn to_array_of_chars<N>(s: str<N>) -> [str<1>; N] {\n    let mut result: [str<1>; N] = [\" \"; N];\n    for i in 0..N {\n        result[i] = char_at(s, i);\n    }\n    result\n}\n\n// Struct\n\nstruct String<N> {\n    value: str<N>,\n    len: u64,\n}\n\n// Implementation over String struct\n\nimpl<N> String<N> {\n    fn new(value: str<N>) -> Self {\n        Self { value, len: N }\n    }\n\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self.value, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self.value, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self.value, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self.value, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self.value, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self.value, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self.value, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self.value, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self.value, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self.value, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self.value, 0, self.len)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self.value)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self.value, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self.value, with_prefix)\n    }\n\n    fn to_array_of_chars(self: Self) -> [str<1>; N] {\n        to_array_of_chars(self.value)\n    }\n}\n\n// Trait\ntrait StringTrait {\n    fn code_at(self, index: u64) -> u8;\n    fn char_at(self, index: u64) -> str<1>;\n    fn index_of<M>(self, substr: str<M>) -> i64;\n    fn last_index_of<M>(self, c: str<M>) -> i64;\n    fn indexes_of<M>(self, c: str<M>) -> Vec<Field>;\n    fn contains<M>(self, substr: str<M>) -> bool;\n    fn occurrences_of<M>(self, c: str<M>) -> u64;\n    fn digit_at(self, index: u64) -> u8;\n    fn hex_digit_at(self, index: u64) -> u8;\n    fn to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn to_uint(self) -> u64;\n    fn to_int(self) -> i64;\n    fn from_hex_to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn from_hex_to_uint(self, with_prefix: bool) -> u64;\n}\n\n// Implementation for str type\nimpl<N> StringTrait for str<N> {\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self, 0, N)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self, with_prefix)\n    }\n}\n\n// Tests for String struct\n#[test]\nfn test_init() {\n    let s = String::new(\"hello\");\n    assert(s.len == 5);\n    assert(s.value == \"hello\");\n}\n\n#[test]\nfn test_char_at() {\n    let s = String::new(\"hello\");\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_code_at() {\n    let s = String::new(\"hello\");\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_index_of() {\n    let s = String::new(\"hello\");\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_last_index_of() {\n    let s = String::new(\"hello\");\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_indexes_of() {\n    let s = String::new(\"hello\");\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_contains() {\n    let s = String::new(\"hello\");\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_occurrences_of() {\n    let s = String::new(\"hello\");\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_digit_at() {\n    let s = String::new(\"20231219\");\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_hex_digit_at() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_to_uint() {\n    let s = String::new(\"20231219\");\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_to_int() {\n    let s = String::new(\"-25\");\n    assert(s.to_int() == -25);\n\n    let s = String::new(\"25\");\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_to_uint_slice() {\n    let s = String::new(\"2023/12/19\");\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_from_hex_to_uint_slice() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_from_hex_to_uint() {\n    let uppercase_hex = String::new(\"0x1324ABCDEF\");\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = String::new(\"0x1234abcdef\");\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = String::new(\"1234abcdef\");\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = String::new(\"0x000001\");\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n\n#[test]\nfn test_to_array_of_chars() {\n    let s = String::new(\"hello\");\n    let arr = s.to_array_of_chars();\n    assert(arr[0] == \"h\");\n    assert(arr[1] == \"e\");\n    assert(arr[2] == \"l\");\n    assert(arr[3] == \"l\");\n    assert(arr[4] == \"o\");\n}\n\n// Tests for String trait\n#[test]\nfn test_trait_char_at() {\n    let s = \"hello\";\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_trait_code_at() {\n    let s = \"hello\";\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_trait_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_trait_last_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_trait_indexes_of() {\n    let s = \"hello\";\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_trait_contains() {\n    let s = \"hello\";\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_trait_occurrences_of() {\n    let s = \"hello\";\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_trait_digit_at() {\n    let s = \"20231219\";\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_trait_hex_digit_at() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_trait_to_uint() {\n    let s = \"20231219\";\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_trait_to_int() {\n    let s = \"-25\";\n    assert(s.to_int() == -25);\n\n    let s = \"25\";\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_trait_to_uint_slice() {\n    let s = \"2023/12/19\";\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint_slice() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint() {\n    let uppercase_hex = \"0x1324ABCDEF\";\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = \"0x1234abcdef\";\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = \"1234abcdef\";\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = \"0x000001\";\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n","path":"/home/maximilien/nargo/github.com/madztheo/noir-string-utils.gitmain/src/lib.nr"}},"names":["main"]}